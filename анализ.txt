Ниже привожу подробное «крипто-исследование» по уже найденным адресам и диапазонам из ваших файлов, а затем конкретный план, как переделать сегментацию и сузить шаблон, чтобы приблизиться к целевому кошельку
1PWo3JeB9jrGwfHDNpdGK54CRas7fsVzXU.

1. Что уже найдено
1.1. Совпадения по префиксу
Все адреса из out_cpu_p[1-3].txt совпадают в первых 7 символах:

1PWo3Je

Дальнейшие символы распределяются так (первые 2–3 байта Base58 после префикса):
* «B6», «Bj», «B…», «Cq», «Lt», «Rh», «TQ», «1F», «Z…», …
Частота «B» после «1PWo3Je» уже заметна: 5 из 24 найденных адресов начинаются на «1PWo3JeB…».
1.2. Числовое расположение приватных ключей
Большинство DEC-значений лежат в диапазоне

∼2.0265×10^21  …  2.0360×10^21

Что почти полностью покрывает окно 71.5 – 72.5 % от полной кривой secp256k1
(это подтверждает комментарии в seg_cpu_part1.txt).

1. Анализ символов после префикса
* Целевой адрес начинается с «…B9jr…».
* Близкие находки:
* 1PWo3JeB6XZ… (B6)
* 1PWo3JeBjDE… (Bj)
Иными словами, вы уже «на расстоянии» одного символа Base58 от желаемого «B9» и двух символов от «B9j».

1. Как сузить поиск
3.1. Сужаем шаблон VanitySearch
Сейчас pattern=1PWo3J (7 симв.).
Предлагаю перейти на двухступенчатый процесс:
a) GPU-фаза с pattern=1PWo3JeB (8 симв.)
* Сложность ↑ ×58 ≈ 6×10^1 от текущей (при GPU ≈ не критично).
b) CPU-добивание «B9jr» («jr» можно оставить на второй проход), т.е. pattern=1PWo3JeB9 или даже 1PWo3JeB9j.
3.2. Перестройка сегментов
Сегменты в seg_cpu_part*.txt сейчас имеют ширину ~4.9 × 10^16 (по 1/24 от процента).
Для более узкого паттерна выгодно:
* Уменьшить ширину в 8–10 раз (≈6 × 10^15).
* Уменьшить шаг между сегментами, перекрытие 1-2 % для страховки.
* Сместить «центр тяжести» к DEC ≈ 2 026 682 282 231 … (число из первой находки p1).
Пример строки:

abs 2026650000000000000000 2026710000000000000000 up cpu_B9j_1 1

3.3. Глобальный threadId в прогрессе
В SegmentSearch уже есть замечание, что надо записывать прогресс как
segIdx = globalThId = blockIdx*nbThreads + threadIdx; иначе все нули — это мы уже обсуждали.
Проверьте, что патч внедрён; иначе прогресс «перетирается», и вы крутитесь в уже пройденных диапазонах.

1. Инновационные приёмы
4.1. «Соседний ключ»
Раз найден приват 0x…C481 (граница curve-order −1), просканируйте ±256 ключей от него — известный трюк: из-за переполнений некоторые кошельки были созданы с off-by-one ошибкой.
4.2. «Base58-пробой»
Для суффикса «B9jrG» можно создать mini-Bloom-filter на стороне GPU:
* Вычисляете первые N бит хеша адреса ещё в ядре и сразу отбрасываете >99 % «мусора», экономя ECC-код + RIPEMD.
4.3. «Half-point mirror»
Если целевой DEC лежит в 71-72 %, зеркальный ключ (n − k) лежит в 28 – 29 % диапазона.
Можно прогнать симметричный сегмент — иногда разработчик путает направление инкремента.

1. Конкретный план действий
Шаг 1. Измените pattern и сегменты
* В VanitySearch запустите:

./VanitySearch -gpu -P -X 8 -p 1PWo3JeB9 -o found_B9.txt \
               -s 2026650000000000000000 -e 2026750000000000000000
Шаг 2. Распараллельте по 16 малых сегментов по ~6×10^15, каждому — отдельный GPU-kernel/CPU-поток.

Шаг 3. По завершении каждой порции проверяйте частотность символов после «B»:
* если «9» начинает появляться, узнайте следующий символ и снова сузьте pattern.

Итог
* Вы уже нашли адреса «B6…» и «Bj…» — то есть реальный поиск «дышит в спину» целевому «B9j…».
* Сужаем шаблон до 1PWo3JeB9, уменьшаем ширину сегментов, центрируем их вокруг 2.0266 × 10^21.
* Исправляем сохранение прогресса и подключаем инновации (Bloom-фильтрация, зеркальный диапазон, off-by-one).
